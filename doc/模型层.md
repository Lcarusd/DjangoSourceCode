

# 模型层

## 一、模型

### A、模型语法

#### 1、简短的例子

**基础:**

每个模型都是 django.db.models.Model 的一个Python 子类。 

模型的每个属性都表示数据库中的一个字段。



**一些技术上的注意事项:**

id字段是自动添加的,但这个行为可以被重写。 

SQL语句使用PostgreSQL语法格式,要注意的是Django 会根据设置文件中指定的数据库来使用相应的SQL语句。

在 INSTALLED_APPS中添加新应用名时,请运行命令manage.py migrate,可先使用manage.py makemigrations 来为它们生成迁移脚本。

#### 2、字段

字段被指定为类属性。 要注意选择的字段名称不要和模型API冲突,比如clean 、save或者delete 。

##### a、字段类型

**模型中的每个字段都是 Field 子类的某个实例。**

> Django 根据字段类的类型确定以下信息:
>
> - 数据库当中的列类型 (比如, INTEGER , VARCHAR )。 
> - 渲染表单时使用的默认HTML 部件(例如, &lt;input type="text"&gt; , &lt;select&gt; )。
> - 最低限度的验证需求,它被用在 Django 管理站点和自动生成的表单中。

##### b、字段选项

有些适用所有字段的通用参数。 这里我们简单介绍一些最常用的:

**null**

如果为True ,Django 将用NULL来在数据库中存储空值。 默认值是False。

**blank**

如果为 True ,该字段允许不填。默认为 False 。

注意,这与 null 不同。 null 纯粹是数据库范畴的,而 blank 是数据验证范畴的。

**choices**
由二元组组成的一个可迭代对象(例如,列表或元组),用来给字段提供选择项。

**default**
字段的默认值。可以是一个值或者可调用对象。如果可调用 ,每有新对象被创建它都会被调用。

**help_text**
表单部件额外显示的帮助内容。

**primary_key**
如果为 True ,那么这个字段就是模型的主键。

主键字段是只读的。如果你在一个已存在的对象上面更改主键的值并且保存,一个新的对象将会在原有对象之外创建出来。

**unique**
如果该值设置为 True , 这个数据字段的值在整张表中必须是唯一的。

##### c、自增主键字段

默认情况下,Django 会给每个模型添加下面这个字段: 

```
id = models.AutoField(primary_key=True)
```

这是一个自增主键字段。



如果你想指定一个自定义主键字段,只要在某个字段上指定primary_key=True即可。

如果Django看到你显式地设置了Field.primary_key,就不会自动添加id列。

每个模型只能有一个字段指定 primary_key=True (无论是显式声明还是自动添加)。

##### d、字段的自述名

每个字段类型 都接受一个可选的位置参数——字段的自述名。

在这个例子中,自述名是 "person's first name":

```
first_name = models.CharField("person's first name", max_length=30)
```

ForeignKey 、ManyToManyField 和 OneToOneField 都要求第一个参数是一个模型类,所以要使**verbose_name** 关键字参数才能指定自述名。

##### e、关系

###### 	多对一关系


​	**Django使用django.db.models.ForeignKey定义多对一关系。**

​	ForeignKey需要一个位置参数:与该模型关联的类。

​	你还可以创建递归的关联关系(对象和自己进行多对一关联)和与尚未定义的模型的关联关系。

​	建议你用被关联的模型的小写名称做为 ForeignKey 字段的名字。

###### 	多对多关系

​	ManyToManyField需要一个位置参数:和该模型关联的类。

​	和使用 ForeignKey 一样,你也可以创建递归的关联关系和与尚未定义关系的模型的关联关系。 

​	建议你以被关联模型名称的复数形式做为 ManyToManyField 的名字(例如toppings )。

​	在哪个模型中设置 ManyToManyField 并不重要,在两个模型中任选一个即可——不要两个模型都设置。通常, ManyToManyField实例应该位于可以编辑的表单中。

###### 	多对多关系中的其他字段

​	有时你可能需要关联数据到两个模型之间的关系上。

​	Django 允许你指定一个模型来定义多对多关系。 你可以将其他字段放在中介模型里面。源模型的 ManyToManyField 字段将使用 through 参数指向中介模型。代码如下:

```
from django.db import models

class Person(models.Model):
￼	name = models.CharField(max_length=128)
	
    def __str__(self):  # __unicode__ on Python 2
￼		return self.name

￼class Group(models.Model):
￼	name = models.CharField(max_length=128)
￼	members = models.ManyToManyField(Person, through='Membership')

￼	def __str__(self):  # __unicode__ on Python 2
￼		return self.name

￼class Membership(models.Model):
	￼person = models.ForeignKey(Person)
￼	 group = models.ForeignKey(Group)
	date_joined = models.DateField()
	invite_reason = models.CharField(max_length=64)
```

在设置中介模型时,要显式指定外键并关联到多对多关系涉及的模型。这个显式声明定义两个模型之间是如何关联的。



> 中介模型有一些限制:
> 中介模型必须有且只有一个外键到源模型(上面例子中的 Group ),或者你必须使ManyToManyField.through_fields 显式指定Django 应该使用的外键。如果你的模型中存在超过一个的外键,并且through_fields 没有指定,将会触发一个无效的错误。对目标模型的外键有相同的限制(上面例子中 的 Person )。 
>

对于通过中介模型与自己进行多对多关联的模型,允许存在到同一个模型的两个外键,但它们将被作为多对多关联关系的两个(不同的)方面。如果有超过两个外键,同样你必须像上面一样指定 through_fields ,否则将引发一个 验证错误。

使用中介模型定义与自身的多对多关系时,你必须设置 symmetrical=False 


与普通的多对多字段不同,你不能使用 add 、create 和赋值语句,比 如：
```
# THIS WILL NOT WORK
beatles.members.add(john)
```

为什么不能这样做? 

这是因为你不能只创建Person和Group之间的关联关系,你还要指定Membership模型中所需要的所有信息;而简单的add 、create和赋值语句是做不到这一点的。所以它们不能在使用中介模型的多对多关系中使用。此时,唯一的办法就是创建中介模型的实例。remove() 方法被禁用也是出于同样的原因。但是 clear() 方法却是可用的。



通过创建中介模型的实例来建立对多对多关系后,你就可以执行查询了。 和普通的多对多字段一样,你可以直接使用被关联模型的属性进行查询:

```
Group.objects.filter(members__name__startswith='Paul')
```

也可以利用中介模型的属性进行查询:

```
Person.objects.filter(
   ￼group__name='The Beatles',
￼	membership__date_joined__gt=date(1961,1,1))
```

###### 	一对一关系

当某个对象想扩展自另一个对象时,最常用的方式就是在这个对象的主键上添加一对一关系。

OneToOneField 要一个位置参数:与模型关联的类。

##### f、跨文件的模型

访问其他应用的模型是非常容易的。 在文件顶部你定义模型的地方,导入相关的模 型来实现它。然后,无论在哪里需要的话,都可以引用它。例如:

```
from django.db import models
from geography.models import ZipCode
	
class Restaurant(models.Model):
	zip_code = models.ForeignKey(ZipCode)
```

##### g、字段命名的限制

Django 对字段的命名只有两个限制:

> 1. 字段的名称不能是Python 保留的关键字,因为这将导致一个Python 语法错误。
> 2. 由于Django 查询语法的工作方式,字段名称中连续的下划线不能超过一个。
>

##### h、自定义字段模型

如果已有的模型字段都不合适,或者你想用到一些很少见的数据库列类型的优点,你可以创建你自己的字段类型。

#### 3、元选项

使用内部的 class Meta 定义模型的元数据,例如:

```
from django.db import models

￼class Ox(models.Model):
￼	horn_length = models.IntegerField()
	
   ￼class Meta:
￼		 ordering = ["horn_length"]
		verbose_name_plural = "oxen"
```

模型元数据是“任何不是字段的数据”,比如排序选项( ordering ),数据表名 ( db_table )或者人类可读的单复数名称( verbose_name和 verbose_name_plural )。在模型中添加 class Meta 是完全可选的,所有选项都不是必须的。

#### 4、模型的属性

模型最重要的属性是管理器。它是通过数据库查询操作提供给Django模型的接口，用于从数据库检索实例。如果没有定义自定义管理器，则默认名称为对象。**管理人员只能通过模型类访问，而不是模型实例。**

#### 5、模型的方法

可以在模型上定义自定义的方法来给你的对象添加自定义的“底层”功能。Manager 方法用于“表范围”的事务,模型的方法应该着眼于特定的模型实例。

例如,下面的模型具有一些自定义的方法:

```
from django.db import models

￼class Person(models.Model):
￼	 first_name = models.CharField(max_length=50)
￼	 last_name = models.CharField(max_length=50)
    ￼birth_date = models.DateField(

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        else:
            return "Baby boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Post-boomer"

    ￼def _get_full_name(self):
    ￼	"Returns the person's full name."
    ￼	return '%s %s' % (self.first_name, self.last_name)
    ￼	full_name = property(_get_full_name
```

模型实例参考具有一个完整的为模型自动生成的方法列表。你可以覆盖它们——参见下文覆盖模型预定义的方法——但是有些方法你会始终想要重新定义:

**get_absolute_url()**

告诉Django 如何计算一个对象的URL。Django在管理站点中使用这个方法,在其它任何需要计算一个对象的URL 时也将用到。任何具有唯一标识自己的URL 的对象都应该定义这个方法。

##### a、覆盖预定义的模型方法

还有另外封装数据库行为的模型方法,你可能想自定义它们。特别是你将经常改变 save() 和 delete() 的工作方式。

你可以自由覆盖这些方法(和其它任何模型方法)来改变它们的行为。

覆盖内建模型方法的一个典型的使用场景是,你想在保存一个对象时做一些其它事情。例如(参见 save() 中关于它接受的参数的文档):

```
from django.db import models

￼class Blog(models.Model):
	￼name = models.CharField(max_length=100)
￼	 tagline = models.TextField()

￼	 def save(self, *args, **kwargs):
￼	 	do_something()
￼ 	 	super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
 	   do_something_else()
```

__必须要记住调用超类的方法—— super(Blog, self).save(*args, **kwargs) —— 来确保对象被保存到数据库中。如果你忘记调用超类的这个方法,默认的行为 将不会发生且数据库不会有任何改变。__

还要记住传递参数给这个模型方法 —— 即 *args, **kwargs 。 

Django 未来将一 直会扩展内建模型方法的功能并添加新的参数。如果在你的方法定义中使用 *args,  **kwargs ,将保证你的代码自动支持这些新的参数。

##### b、执行自定义的SQL

另外一个常见的需求是在模型方法和模块级别的方法中编写自定义的SQL语句。

#### 6、模型继承

Django 中的模型继承与 Python 中普通类继承方式几乎完全相同,这表示自定义的

模型类应该继承django.db.models.Model 。



在Django中有3种风格的继承：
> 1. 通常，你只想使用父类来持有一些信息，你不想在每个子模型中都敲一遍。这 个类永远不会单独使用，所以你使用抽象基类。
> 2. 如果你继承一个已经存在的模型且想让每个模型具有它自己的数据库表，那么 应该使用多表继承。
> 3. 最后，如果你只是想改变模块Python 级别的行为，而不用修改模型的字段，你 可以使用代理模型。

##### a、抽象基类

编写完基类之后，在 Meta类中设置 abstract=True ，该类就不能创建任何数据表。 取而代之的是，当它被用来作为一个其他model的基础类时，将被加入那一子类中。如果抽象化基础类和它的子类有相同的项，那么将出现error(并且Django将返回一个exception)。

```
from django.db import models

class CommonInfo(models.Model):
	name = models.CharField(max_length=100)
	age = models.PositiveIntegerField()

	class Meta:
		abstract = True

class Student(CommonInfo):
	home_group = models.CharField(max_length=5)
```

 CommonInfo 模型无法像一般的Django模型一样使用，因为它是一个抽象化基础类。它无法生成数 据表单或者管理器，并且不能实例化或者储存。 它提供一种在 Python 语言层级上提取公共信息的方式，但在数据库层级上，各个子类仍然只创建一个数据库。

###### 元继承

当一个抽象类被创建的时候, Django会自动把你在基类中定义的 Meta 作为子类的 一个属性。如果子类没有声明自己的Meta 类, 他将会继承父类的Meta. 如果子类想 要扩展父类 的，可以继承父类的 Meta 即可，例如：

```
from django.db import models

class CommonInfo(models.Model):
	# ...
	class Meta:
		abstract = True
		ordering = ['name']

class Student(CommonInfo):
	# ...
	
	class Meta(CommonInfo.Meta):
		db_table = 'student_info'
```

 继承时，Django 会对基类的 Meta类做一个调整:在安装 Meta属性之前，Django 会设置 abstract=False 。 当 然，你可以让一个抽象类继承另一个抽象基类，不过每次都要显式地设置abstract=True 。

###### 小心使用related_name

如果你在 ForeignKey 或 ManyToManyField 字段上使用 related_name 属性，你必须总是为该字段指定一个唯一的反向名称。但在抽象基类上这样做就会引发一个很严重的问题。因为 Django 会将基类字段添加到每个子类当中，而每个子类的字段属性值都完全相同 (这里面就包括 related_name )。

当你在(且仅在)抽象基类中使用 related_name 时，如果想绕过这个问题，名称 中就要包含 '%(app_label)s' 和 '%(class)s' ：

- '%(class)s' 会替换为子类的小写加下划线格式的名称，字段在子类中使 用。
- '%(app_label)s' 会替换为应用的小写加下划线格式的名称，应用包含子 类。


例如，假设有一个app叫做 common/models.py :

```
from django.db import models

class Base(models.Model):
	m2m = models.ManyToManyField(OtherModel, related_name="%(app
 									_label)s_%(class)s_related")

	class Meta:
 		abstract = True

class ChildA(Base):
	pass

class ChildB(Base):
	pass
```


ChildA.m2m 字段的反向名称是 childa_related，而 ChildB.m2m 字段的反向名称是 childb_related。这取决于你如何使用 '%(class)s' 和 '%(app_label)s 来构造你的反向名称。如果你没有在抽象基类中为某个关联字段定义 related_name 属性，那么默认的反向名称就是子类名称加上 '_set' ，它能否正常工作取决于你是否在子类中定义了同名字段。

##### b、多表继承

使用这种继承方式时，同一层级下的每个子 model 都是一个真正意义上完整的 model 。 每个子 model 都有专属的数据表，都 可以查询和创建数据表。 继承关系在子 model 和它的每个父类之间都添加一个链 接 (通过一个自动创建的 OneToOneField 来实现)。

```
from django.db import models

class Place(models.Model):
	name = models.CharField(max_length=50)
	address = models.CharField(max_length=80)

class Restaurant(Place):
	serves_hot_dogs = models.BooleanField(default=False)
	serves_pizza = models.BooleanField(default=False)
```


Place 里面的所有字段在 Restaurant 中也是有效的，只不过数据保存在另外 一张数据表当中。所以下面两个语句都是可以运行的:

```
Place.objects.filter(name="Bob's Cafe")
Restaurant.objects.filter(name="Bob's Cafe")
```

如果你有一个 Place ，那么它同时也是一个 Restaurant ， 那么你可以使用子 model 的小写形式从 Pl Place 对象中获得与其对应的 Restaurant 对象:

```
p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
p.restaurant
```

###### 多表继承中的Meta

子 model 并不能访问它父类的 Meta 类。但是在某些受限的情况下，子类可以从父类继承某些 Meta :如果子类没有指定 ordering 属性或 get_latest_by 属性，它就会从父类中继承这些属性。

###### 继承与反向关联

因为多表继承使用了一个隐含的 OneToOneField 来链接子类与父类，所以像上例 那样，你可以用父类来指代子类。**但是这个 OnetoOneField 字段默认的related_name 值与 ForeignKey 和 ManyToManyField 默认的反向名称相同。如果你与其他 model 的子类做多对一或是多对多关系，你就必须在每个多对一 和多对多字段上强制指定 related_name 。**如果你没这么做，Django 就会在你运 行 验证(validation) 时抛出异常。

###### 指定链接父类的字段

Django 会自动创建一个 OneToOneField 字段将子类链接至非抽象的父 model 。**如果你想指定链接父类的属性名称，你可以创建你自己的OneToOneField 字段并设置 parent_link=True ，**从而使用该字段链接父类。

##### c、代理模型

有时，你可能只想更改 model 在 Python 层的行为实现。比如:更改默认的 manager ，或是添加一个新方法。而这，正是代理 model 继承方式要做的:为原始 model 创建一个代理 。你可以创建，删除，更新代理 model 的实例，而且所有的数据都可以像使用原始 model 一 样被保存。 不同之处在于:你可以在代理 model 中改变默认的排序设置和默认的 manager ，而不会对原始 model 产生影响。

**声明代理 model 和声明普通 model 没有什么不同。 设置 Meta 类中 proxy 的值 为 True ，就完成了对代理 model 的声明。**

```
from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)

class MyPerson(Person):
	class Meta:
		proxy = True

	def do_something(self):
		# ...
		pass
```

MyPerson 类和它的父类 Person 操作同一个数据表。特别的是， Person 的 任何实例也可以通过 MyPerson 访问，反之亦然:

```
p = Person.objects.create(first_name="foobar")
MyPerson.objects.get(first_name="foobar")  
```


 你也可以使用代理 model 给 model 定义不同的默认排序设置。

```
class OrderedPerson(Person):
	class Meta:
		ordering = ["last_name"]
		proxy = True
```

###### 查询集始终返回请求的模型

代理对象的要点是，依赖于原生 Person 对象的代码仍然使用它，而你可以使用你添加进来的扩展对象(它不会依赖其它任何代码)。而并不是将 Person 模型(或者其它)在所有地方替换为其它你自己创建的模型。

###### 基类的限制

代理模型必须继承自一个非抽象基类。 你不能继承自多个非抽象基类，这是因为一个代理 model 不能连接不同的数据表。 代理 model 也可以继承任意多个抽象基 类，但前提是它们没有 定义任何 model 字段。

###### 代理模型的管理器

如果你没有在代理模型中定义任何管理器 ，代理模型就会从父类中继承管理器 。如果你在代理 模型中定义了一个 管理器 ,它就会变成默认的管理器 ，不过定义在父类中的管理器仍然有效。

```
from django.db import models

class NewManager(models.Manager):
	# ...
	pass

class MyPerson(Person):
	objects = NewManager()
	
	class Meta:
		proxy = True
```



###### 代理模型与非托管模型间的差异

一般规则是:

- 如果你要借鉴一个已有的模型或数据表，且不想涉及所有的原始数据表的列， 那就令 Meta.managed=False 。通常情况下，对数据库视图创建 模型或是数 据表不需要由 Django 控制时，就使用这个选项。
- 如果你想对 model 做 Python 层级的改动，又想保留字段不变，那就令 Meta.proxy=True 。因此在数据保存时，代理 model 相当于完全复制了原始模型的存储结构。

##### d、Field name "hiding" is not permitted

普通的 Python 类继承允许子类覆盖父类的任何属性。 **但在 Django 中，重写 Field 实例是不允许的(至少现在还不行)。**如果基类中有一个 author 字段，你就不能在子类中创建任何名为 author 的字段。重写父类的字段会导致很多麻烦，比如:初始化实例(指定在 Model.init中被实例化的字段) 和序列化。而普通的 Python 类继承机制并不能处理好这些特性。所以 Django 的继承机制被设计成与 Python 有所不同，这样做并不是随意而为的。

### B、字段选项

注意

严格意义上来讲， Model 是定义在django.db.models.fields里面，但为了使用方便，它们被导入到 django.db.models中；标准上，我们导入from django.db import models，然后使用?models.<Foo>Field的形式使用字段。

#### 1、字段选项(*下列参数全部字段都可用，且都是可选择的。*)

**null**

**如果为True，Django 将空值以NULL 存储到数据库中。默认值是 False。**

字符串字段例如CharField和TextField要避免使用null，因为空字符串值将始终储存为空字符串而不是NULL。如果字符串字段的null=True，那意味着对于“无数据”有两个可能的值：NULL 和空字符串。**在大多数情况下，对于“无数据”声明两个值是赘余的，Django 的惯例是使用空字符串而不是NULL。**

无论是字符串字段还是非字符串字段，如果你希望在表单中允许空值，你将还需要设置blank=True，因为null 仅仅影响数据库存储。

**blank**

**如果为True，则该字段允许为空白。 默认值是 False。**

注意它与null不同。**null纯粹是数据库范畴的概念，而blank是数据验证范畴的。**如果字段设置blank=True，表单验证时将允许输入空值。如果字段设置blank=False，则该字段为必填。

**choices**

**它是一个可迭代的结构(比如，列表或是元组)，由可迭代的二元组组成(比如[(A, B), (A, B) ...])，用来给这个字段提供选择项。如果设置了 choices ，默认表格样式就会显示选择框，而不是标准的文本框，而且这个选择框的选项就是choices中的元组。每个元组中的第一个元素，是存储在数据库中的值；第二个元素是该选项更易理解的描述。**

一般来说，最好在模型类内部定义choices，然后再给每个值定义一个合适名字的常量。

```
from django.db import models

class Student(models.Model):
    FRESHMAN = 'FR'
    SOPHOMORE = 'SO'
    JUNIOR = 'JR'
    SENIOR = 'SR'
    YEAR_IN_SCHOOL_CHOICES = (
        (FRESHMAN, 'Freshman'),
        (SOPHOMORE, 'Sophomore'),
        (JUNIOR, 'Junior'),
        (SENIOR, 'Senior'),
    )
    year_in_school = models.CharField(max_length=2,
                                choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN)

	def is_upperclass(self):
		return self.year_in_school in (self.JUNIOR, self.SENIOR)
```

尽管你可以在模型类的外部定义choices然后引用它，但是在模型类中定义choices和其每个choice的name(即元组的第二个元素)可以保存所有使用choices的类的信息， 也使得choices更容易被应用。



你也可以归类可选的choices到已命名的组中用来达成组织整理的目的:

```
MEDIA_CHOICES = (
    ('Audio', (
    	('vinyl', 'Vinyl'),
    	('cd', 'CD'),
        )
    ),
    ('Video', (
         ('vhs', 'VHS Tape'),
         ('dvd', 'DVD'),
        )
    ),
    ('unknown', 'Unknown'),
)
```

每个元组的第一个元素是组的名字。第二个元素是一组可迭代的二元元组，每一个二元元组包含一个值和一个给人看的名字构成一个选项。分组的选项可能会和未分组的选项合在同一个list中。 （就像例中的unknown选项）。



对于有choices set的模型字段, Django 将会加入一个方法来获取当前字段值的易于理解的名称(即元组的第二个值)参见数据库API文档中的get_FOO_display()。

请注意**choices可以是任何可迭代的对象 – 不是必须是列表或者元组。这一点使你可以动态的构建choices。**但是如果你发现你自己搞不定动态的choices，你最好还是使用ForeignKey来构建一个合适的数据库表。如果有数据变动的话，choices意味着那些变动不多的静态数据。

除非blank=False 和default一起在字段中被设置，否则，可选择菜单将会有"---------" 的标签。要重写这个行为, 需要加入一个包含None的元组到 choices里面; 例如 (None, 'Your String For Display'). 或者, 你可以在操作有意义的地方用一个空字符串代替None - 比如在一个 CharField.

**db_column**

**数据库中用来表示该字段的名称。如果未指定，那么Django将会使用Field名作为字段名。**

如果你的数据库列名为SQL语句的保留字，或者是包含不能作为Python 变量名的字符，如连字符，没问题。Django 会在后台给列名和表名加上双引号。

**db_index**

**若值为 True, 则 django-admin sqlindexes 将会为字段输出 CREATE INDEX 语句。(注:为此字段创建索引)**

**db_tablespace**

**如果该字段有索引的话，database tablespace的名称将作为该字段的索引名。**

 如果DEFAULT_INDEX_TABLESPACE 已经设置，则默认值是由DEFAULT_INDEX_TABLESPACE指定, 如果没有设置则由 db_tablespace 指定，如果后台数据库不支持表空间，或者索引，则该选项被忽略。

**default**
**该字段的默认值. 它可以是一个值或者一个可调用对象.。如果是一个可调用对象，那么在每一次创建新对象的时候，它将会调用一次。**

**editable**

**如果设为False, 这个字段将不会出现在 admin 或者其他 ModelForm. 他们也会跳过模型验证. 默认是True.**

**error_messages**

**error_messages 参数能够让你重写默认抛出的错误信息。**

通过指定 key 来确认你要重写的错误信息。error_messages 的 key 值包括 null, blank, invalid, invalid_choice, unique, 和 unique_for_date.

**help_text**

**额外的 ‘help' 文本将被显示在表单控件form中。**

即便你的字段没有应用到一个form里面，这样的操作对文档化也很有帮助。

注意这不会自动添加HTML标签。需要你在 help_text 包含自己需要的格式。例如:

```
help_text="Please use the following format: <em>YYYY-MM-DD</em>."
```

另外, 你可以使用简单文本和django.utils.html.escape()以避免任何HTML特定的字符。请确保你所使用的help text能够避免那些由不受信任的用户进行的跨站点脚本攻击。

**primary_key**

**若为 True, 则该字段会成为模型的主键字段。**

primary_key=True 暗含着null=False和unique=True.一个对象上只能拥有一个主键。主键字段是只读的。如果你改变了一个已存在对象上的主键并且保存的话，会创建一个新的对象，而不是覆盖旧的。

**unique**

**如果为True, 这个字段在表中必须有唯一值。**

这是一个在数据库级别的强制性动作,并且通过模型来验证。除了ManyToManyField、OneToOneField和FileField以外的其他字段类型都可以使用这个设置。注意当设置unique为True时，你不需要再指定 db_index，因为unique 本身就意味着一个索引的创建。

**unique_for_date**

**当设置它为DateField和DateTimeField字段的名称时，表示要求该字段对于相应的日期字段值是唯一的。**

例，有一个title 字段设置unique_for_date="pub_date"，那么Django 将不允许两个记录有相同的title 和pub_date。注意，如果你将它设置为DateTimeField，只会考虑其日期部分。此外，如果USE_TZ 为True，检查将以对象保存时的当前的时区进行。

这是在模型验证期间通过Model.validate_unique() 强制执行的，而不是在数据库层级进行验证。如果unique_for_date约束涉及的字段不是ModelForm中的字段（例如，exclude中列出的字段或者设置了editable=False），Model.validate_unique() 将忽略该特殊的约束。

**unique_for_month**

类似unique_for_date，只是要求字段对于月份是唯一的。

**unique_for_year**

类似unique_for_date 和 unique_for_month。

**verbose_name**

**一个字段的可读性更高的名称。**

若用户没有设定冗余名称字段，Django会自动将该字段属性名中的下划线转换为空格，并用它来创建冗余名称。

**Field.validators**

**该字段将要运行的一个Validator 的列表。**

**注册和获取查询**

**Field 实现了查询注册API。该API 可以用于自定义一个字段类型的可用的查询，以及如何从一个字段获取查询。**

#### 2、字段类型

**自增字段**

```
class AutoField(**options)
```

**一个根据实际ID自动增长的IntegerField 。**你通常不需要直接使用;如果不指定,一个主键字段将自动添加到你创建的模型中。

**BigIntegerField**

```
class BigIntegerField([**options])
```

**一个64位整数, 类似于一个IntegerField** 。

它的值的范围是-9223372036854775808 到9223372036854775807之间。这个字段默认的表单组件是一个TextInput。

**BinaryField**

```
class BinaryField([**options])
```

**这是一个用来存储原始二进制码的Field。**

只支持bytes 赋值，注意这个Field只有很有限的功能。例如，不大可能在一个BinaryField 值的数据上进行查询。

**BooleanField**

```
class BooleanField(**options)
```

**true/false 字段。**

此字段的默认表单挂件是一个CheckboxInput。如果你需要设置null 值，则使用NullBooleanField 来代替BooleanField。如果Field.default没有指定的话， BooleanField 的默认值是 None。

**CharField**

```
class CharField(max_length=None[, **options])
```

**一个用来存储从小到很大各种长度的字符串的地方。**

CharField必须接收一个额外的参数:

```
CharField.max_length
```

如果你在写一个需要导出到多个不同数据库后端的应用，你需要注意某些后端对max_length有一些限制。

**CommaSeparatedIntegerField**

```
class CommaSeparatedIntegerField(max_length=None[, **options])
```

**一个逗号分隔的整数字段。**

像 CharField一样， 需要一个max_length 参数， 同时数据库移植时也需要注意。

**DateField**

```
class DateField([auto_now=False, auto_now_add=False, **options])
```

**这是一个使用Python的datetime.date实例表示的日期。**

有几个额外的设置参数:

> **DateField.auto_now**
>
> 每次保存对象时，自动设置该字段为当前时间。用于"最后一次修改"的时间戳。注意，它*总是*使用当前日期；和你可以覆盖的那种默认值不一样。
>
> **DateField.auto_now_add**
>
> 当对象第一次被创建时自动设置当前时间。用于创建时间的时间戳. 它*总是*使用当前日期；和你可以覆盖的那种默认值不一样。

该字段默认对应的表单控件是一个TextInput。 在管理员站点添加了一个JavaScript写的日历控件，和一个“Today"的快捷按钮。包含了一个额外的invalid_date错误消息键。auto_now_add, auto_now, and default 这些设置是相互排斥的. 他们之间的任何组合将会发生错误的结果。

**DateTimeField**

```
class DateTimeField([auto_now=False, auto_now_add=False, **options])
```

它是通过Python datetime.datetime实例表示的日期和时间. 携带了跟DateField一样的额外参数。该字段默认对应的表单控件是一个单个的TextInput(单文本输入框). 管理界面是使用两个带有 JavaScript控件的TextInput文本框。

**DecimalField**

```
class DecimalField(max_digits=None, decimal_places=None[, **options])
```

**用python中 Decimal 的一个实例来表示十进制浮点数。**

有两个必须的参数:

> **DecimalField.max_digits**
>
> 位数总数，包括小数点后的位数。该值必须大于等于`decimal_places`.
>
> **DecimalField.decimal_places**
>
> 小数点后的数字数量

**DurationField**

```
class DurationField([**options])
```

**用作存储一段时间的字段类型**。

**EmailField**

```
class EmailField([max_length=254, **options])
```

**一个 CharField 用来检查输入的email地址是否合法。**

它使用 EmailValidator 来验证输入合法性。默认最大长度 max_length 从75增加到254以符合RFC3696/5321标准。

**FileField**

```
class FileField([upload_to=None, max_length=100, **options])
```

**一个上传文件的字段。**

注，FileField字段不支持primary_key和unique参数，若使用会有TypeError错误

有两个可选参数：

> **FileField.upload_to**

一个本地文件系统的路径，它将附加到MEDIA_ROOT 设置的后面来确定url 属性的值。这个路径可能会包含一个 strftime() 格式串,并且会在文件上传时被替换为实际的date/time作为文件路径 (这样上传的文件就不会塞满你指定的文件夹了)。

它还可以是一个可调用对象。如函数，将调用它来获取上传路径，包括文件名。这个可调用对象必须接受两个参数，并且返回一个Unix 风格的路径（带有前向/）给存储系统。将传递的两个参数为：

| 参数     | 简介                                                         |
| -------- | ------------------------------------------------------------ |
| instance | FileField 定义所在的模型的实例。更准确地说，就是当前文件的所在的那个实例。大部分情况下，这个实例将还没有保存到数据库中，若它用到默认的AutoField 字段，它的主键字段还可能没有值。 |
| filename | 最初提供给该文件的文件名。 在确定最终目的地路径时，这可能会也可能不会被考虑在内。 |

> **FileField.storage**

一个Storage 对象，用于你的文件的存取。



在模型中调用FileField 或 ImageField (见下方) 需如下几步：

> 1. 在你的settings文件中, 你必须要定义 MEDIA_ROOT 作为Django存储上传文件的路径(从性能上考虑，这些文件不能存在数据库中。) 定义一个 MEDIA_URL 作为基础的URL或者目录。确保这个目录可以被web server使用的账户写入。
> 2. 在模型中添加[`FileField`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.FileField) 或 [`ImageField`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.ImageField) 字段, 定义 [`upload_to`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.FileField.upload_to)参数，内容是 [`MEDIA_ROOT`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/settings.html#std:setting-MEDIA_ROOT) 的子目录，用来存放上传的文件。
> 3. 数据库中存放的仅是这个文件的路径 （相对于MEDIA_ROOT). 你很可能会想用由Django提供的便利的url 属性。比如说, 如果你的ImageField 命名为 mug_shot, 你可以在template中用 ``获得你照片的绝对路径。

例如，如果你的 MEDIA_ROOT设定为_'/home/media'_ ，并且 upload_to设定为 _'photos/%Y/%m/%d'_。 

upload_to的_'%Y/%m/%d'_被strftime()所格式化；_'%Y'_ 将会被格式化为一个四位数的年份, _'%m' _被格式化为一个两位数的月份'%d'是两位数日份。

如果你在Jan.15.2007上传了一个文件，它将被保存在/home/media/photos/2007/01/15目录下。如果你想获得上传文件的存盘文件名，或者是文件大小，你可以分别使用 name 和 size 属性。

注意：

- 保存的文件作为模型存储在数据库中的一部分，所以在磁盘上使用的实际的文件名在模型保存完毕之前是不可靠的。
- 上传的文件对应的URL可以通过使用 url 属性获得. 在内部，它会调用 ?Storage类下的url()方法。
- 值得注意的是，无论你在任何时候处理上传文件的需求，你都应该密切关注你的文件将被上传到哪里，上传的文件类型，以避免安全漏洞。*认证所有上传文件* 以确保那些上传的文件是你所认为的文件。
- 甚至是上传HTML文件也值得注意，它可以通过浏览器（虽然不是服务器）执行，也可以引发相当于是XSS或者CSRF攻击的安全威胁。
- FileField 实例将会在你的数据库中创建一个默认最大长度为100字符的varchar列。就像其他的fields一样, 你可以用 max_length 参数改变最大长度的值。

**FileField 和FieldFile**

```
class FieldFile [source]
```

**当你添加 FileField 到你的模型中时, 你实际上会获得一个 FieldFile的实例来替代将要访问的文件。** 除了继承至 django.core.files.File的功能外, 这个类还有其他属性和方法可以用于访问文件:

> **FieldFile.url**

通过潜在[`Storage`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/files/storage.html#django.core.files.storage.Storage) 类的[`url()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/files/storage.html#django.core.files.storage.Storage.url)方法可以只读地访问文件的URL。

> **FieldFile.open(mode='rb')[source]**

该方法像标准的Python `open()` 方法,并可通过?`mode`参数设置打开模式.

> **FieldFile.close()[source]**

该方法像标准的Python`file.close()` 方法,并关闭相关文件.

> **FieldFile.save(name, content, save=True)[source]**

这个方法会将文件名以及文件内容传递到字段的storage类中,并将模型字段与保存好的文件关联. 如果想要手动关联文件数据到你的模型中的 FileField实例, 则save() 方法总是用来保存该数据。

方法接受两个必选参数: name 文件名和 content 文件内容。可选参数save 控制模型实例在关联的文件被修改时是否保存。默认为 True。

注意参数 `content` 应该是 [`django.core.files.File`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/files/file.html#django.core.files.File)的一个实例, 而不是Python内建的File对象.你可以用如下方法从一个已经存在的Python文件对象来构建 [`File`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/files/file.html#django.core.files.File) :

```
from django.core.files import File
# Open an existing file using Python's built-in open()
f = open('/tmp/hello.world')
myfile = File(f)

```

或者，你可以像下面的一样从一个python字符串中构建

```
from django.core.files.base import ContentFile
myfile = ContentFile("hello world")

```

> **FieldFile.delete(save=True)[source]**

删除与此实例关联的文件，并清除该字段的所有属性。注意︰ 如果它碰巧是开放的调用 `delete()` 方法 时，此方法将关闭该文件。

模型实例save的文件与此字段关联的可选保存参数控件已被删除。默认值为 True。

注意，model删除的时候，与之关联的文件并不会被删除。如果你要把文件也清理掉，你需要自己处理。

**FilePathField**

```
class FilePathField(path=None[, match=None, recursive=False, 											max_length=100, **options])
```

**一个CharField ，内容只限于文件系统内特定目录下的文件名。**

有三个参数, 其中第一个是必需的:

> **FilePathField.path**

必填。这个FilePathField 应该得到其选择的目录的绝对文件系统路径。例如: "/home/images"。

> **FilePathField.match**

可选的。FilePathField 将会作为一个正则表达式来匹配文件名。但请注意正则表达式将将被作用于基本文件名，而不是完整路径。例如: **"foo.*.txt$"**, 将会匹配到一个名叫**foo23.txt**的文件，但不匹配到 bar.txt 或者 foo23.png。

有一点需提醒的是 match只匹配基本文件名, 而不是整个文件路径。 如:

```
FilePathField(path="/home/images", match="foo.*", recursive=True)

```

将匹配/home/images/foo.png而不是/home/images/foo/bar.png 因为只允许匹配基本文件名(foo.png 和 bar.png)。

> **FilePathField.recursive**

可选的。True 或 False。默认是False。声明是否包含所有子目录的路径。

> **FilePathField.allow_files**

可选的。True 或 False。默认是True。声明是否包含指定位置的文件。该参数或allow_folders 中必须有一个为 True。

> **FilePathField.allow_folders**

是可选的。输入 True 或者 False。默认值为 False.声明是否包含指定位置的文件夹。该参数或 allow_files 中必须有一个为 True。

**FloatField**

```
class FloatField([**options])
```

**用Python的一个float 实例来表示一个浮点数。**

> **FloatField 与DecimalField**

有时候FloatField 类会和DecimalField 类发生混淆。虽然它们表示都表示实数，但是二者表示数字的方式不一样。FloatField 使用的是Python内部的 float 类型, 而DecimalField 使用的是Python的 Decimal 类型。*具体可查看Python中的 decimal 模块。*

**ImageField**

```
class ImageField([upload_to=None, height_field=None, 
					width_field=None, max_length=100, **options])
```

**继承了 FileField的所有属性和方法, 但还对上传的对象进行校验，确保它是个有效的image。**

ImageField 有两个额外的可选参数：

> > **ImageField.height_field**
>
> 该属性的设定会在模型实例保存时,自动填充图片的高度。
>
> > **ImageField.width_field**
>
> 该属性的设定会在模型实例保存时,自动填充图片的宽度。

ImageField字段需要调用Pillow 库。此字段的默认表单工具是ClearableFileInput。

**IntegerField**

```
class IntegerField([**options])
```

**一个整数。**在Django所支持的所有数据库中，从 -2147483648 到 2147483647 范围内的值是合法的。

**GenericIPAddressField**

```
class GenericIPAddressField([protocol=both, 
							unpack_ipv4=False, **options])
```

一个 IPv4 或 IPv6 地址, 字符串格式 (例如 192.0.2.30 或 2a02:42fe::4)。

> IPv6 地址会根据 RFC 4291 章节 2.2所规范, 包括该章节中第三段的的IPv4格式建议, 就像 ::ffff:192.0.2.0这样. 例如, 2001:0::0:01 将会被规范成 2001::1, ::ffff:0a0a:0a0a 被规范成 ::ffff:10.10.10.10. 所有字符都会被转换成小写。

> GenericIPAddressField.protocol**

限制有效输入的协议类型。允许的值是 'both' (默认值), 'IPv4' 或 'IPv6'. 匹配不区分大小写。

> **GenericIPAddressField.unpack_ipv4**

解析IPv4映射地址如 `::ffff:192.0.2.1`.如果启用该选项，则地址将被解析到`192.0.2.1`.默认为禁用。只有当`协议` 设置为`'both'`时才可以使用。

如果允许空白值，则必须允许null值，因为空白值存储为null。

**NullBooleanField**

```
class NullBooleanField([**options])
```

类似BooleanField, 但是允许 NULL作为一个选项。使用此代替null=True的BooleanField。

**PositiveIntegerField（正整数字段）**

```
class PositiveIntegerField([**options])
```

**类似 IntegerField, 但值必须是正数或者零(0)。**从0到2147483647的值在Django支持的所有数据库中都是安全的。由于向后兼容性原因，接受值0。

**PositiveSmallIntegerField**

```
class PositiveSmallIntegerField([**options])
```

该模型字段类似 PositiveIntegerField, 但是只允许小于某一特定值（依据数据库类型而定）。从0 到 32767 这个区间，对于Django所支持的所有数据库而言都是安全的。

**SlugField**

```
class SlugField([max_length=50, **options])
```

Slug 是一个新闻术语（通常叫做短标题）。**一个slug只能包含字母、数字、下划线或者是连字符，通常用来作为短标签。通常它们是用来放在URL里的。**

**SmallIntegerField**

```
class SmallIntegerField([**options])
```

与 IntegerField这个字段类型很类似,不同的是SmallInteger类型只能在一个确定的范围内(数据库依赖)。对于django来讲，该字段值在 -32768 至 32767这个范围内对所有可支持的数据库都是安全的。

**TextField**

```
class TextField([**options])
```

**大文本字段**

如果你在这个字段类型中使用了max_length属性，它将会在渲染页面表单元素Textarea 时候体现出来。但是并不会在model或者数据库级别强制性的限定字段长度。请使用CharField。

**TimeField**

```
class TimeField([auto_now=False, auto_now_add=False, **options])
```

时间字段，和datetime.time 一样。接受与DateField相同的自动填充选项。

**URLField**

```
class URLField([max_length=200, **options])
```

一个CharField 类型的URL。

**UUIDField**

```
class UUIDField([**options])
```

**一个用来存储UUID的字段。使用Python的UUID类。** 当使用PostgreSQL数据库时，该字段类型对应的数据库中的数据类型是uuid，使用其他数据库时，数据库对应的是char(32)类型。

使用UUID类型相对于使用具有[`primary_key`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.primary_key)参数的[`AutoField`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.AutoField)类型是一个更好的解决方案。 数据库不会自动生成UUID，所以推荐使用[`default`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.default)参数：

```
import uuid
from django.db import models

class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields

```

注意：这里传递给default是一个可调用的对象（即一个省略了括号的方法），而不是传递一个UUID实例给default

#### 关系字段

**ForeignKey**

```
class ForeignKey(othermodel[, **options])
```

四中使用方式：

- 多对一关系。**需要一个位置参数：与该模型关联的类。**
- 若要创建一个递归的关联 —— 对象与自己具有多对一的关系 —— 请使用**models.ForeignKey('self')**。


- 如果你需要关联到一个还没有定义的模型，你可以**使用模型的名字而不用模型对象本身**：

```
from django.db import models

class Car(models.Model):
    manufacturer = models.ForeignKey('Manufacturer')
    # ...

class Manufacturer(models.Model):
    # ...
    pass
```

- 若要引用在其它应用中定义的模型，你可以用带有完整标签名的模型来显式指定。例如，Manufacturer 模型是在一个名为production 的应用中定义的，你应该这样使用它：

```
class Car(models.Model):
    manufacturer = models.ForeignKey('production.Manufacturer')
```

在解析两个应用之间具有相互依赖的导入时，这种引用将会很有帮助。

注意：

> ForeignKey 会自动创建数据库索引。你可以通过设置db_index 为False 来取消。如果你创建外键是为了一致性而不是用来Join，或者如果你将创建其它索引例如部分或多列索引，你也许想要避免索引的开销。
>
> 不建议从一个没有迁移的应用中创建一个ForeignKey 到一个具有迁移的应用。

###### 数据库中的表示

在幕后，Django 会在字段名上添加"_id" 来创建数据库中的列名。你可以通过显式指定db_column改变它。但是，你的代码永远不应该处理数据库中的列名称，除非你需要编写自定义的SQL。你应该永远只处理你的模型对象中的字段名称。

###### 参数

ForeignKey 接受额外的参数集，全都是可选的。

> **ForeignKey.limit_choices_to**

当这个字段使用模型表单或者Admin 渲染时（默认情况下，查询集中的所有对象都可以使用），为这个字段设置一个可用的选项。它可以是一个字典、一个Q 对象或者一个返回字典或Q对象的可调用对象。

```
staff = models.ForeignKey(User,limit_choices_to={'is_staff':True})
```

将使得模型表单 中对应的字段只列出is_staff=True 的Users。

如果limit_choices_to 自己本身是或者返回一个用于复杂查询的Q 对象，当字段没有在模型的ModelAdmin中的raw_id_fields 列出时，它将只会影响Admin中的可用的选项。

> **ForeignKey.related_name**

**这个名称用于让关联的对象反查到源对象。它还是related_query_name 的默认值（关联的模型进行反向过滤时使用的名称）**。注意，当你为抽象模型定义关联关系的时，必须设置这个参数的值；而且当你这么做的时候需要用到一些特殊语法。

如果你不想让Django 创建一个反向关联，请设置related_name 为 `'+'` 或者以`'+'` 结尾。 例如，下面这行将确User 模型将不会有到这个模型的返回关联：

```
user = models.ForeignKey(User, related_name='+')
```

> **ForeignKey.related_query_name**

**这个名称用于目标模型的反向过滤。**如果设置了related_name，则默认为它的值，否则默认值为模型的名称：

```
# 用related_query_name声明ForeignKey
class Tag(models.Model):
    article = models.ForeignKey(Article, related_name="tags", related_query_name="tag")
    name = models.CharField(max_length=255)

# 这就是反向过滤器的名称
Article.objects.filter(tag__name="important")
```

> **ForeignKey.to_field**

关联到的关联对象的字段名称。默认地，Django 使用关联对象的主键。

> **ForeignKey.db_constraint**

控制是否在数据库中为这个外键创建约束。默认值为True，而且这几乎一定是你想要的效果；设置成False 对数据的完整性来说是很糟糕的。即便如此，有一些场景你也许想要这么设置：

- 你有遗留的无效数据。
- 你正在对数据库缩容。

如果被设置成False，访问一个不存在的关联对象将抛出 DoesNotExist 异常。

> **ForeignKey.on_delete**

当一个ForeignKey 引用的对象被删除时，Django 默认模拟SQL 的ON DELETE CASCADE 的约束行为，并且删除包含该ForeignKey的对象。这种行为可以通过设置on_delete 参数来改变。

例如，如果你有一个可以为空的ForeignKey，在其引用的对象被删除的时你想把这个ForeignKey 设置为空：

```python
user = models.ForeignKey(User, blank=True, null=True, 													on_delete=models.SET_NULL)
```

on_delete 在django.db.models中可以找到的值有：

- CASCADE

  级联删除；默认值。

- PROTECT

  抛出ProtectedError 以阻止被引用对象的删除，它是django.db.IntegrityError 的一个子类。

- SET_NULL

  把ForeignKey 设置为null； null 参数为True 时才可以这样做。

- SET_DEFAULT

  ForeignKey 值设置成它的默认值；此时必须设置ForeignKey 的default 参数。

- SET()

  设置ForeignKey 为传递给SET() 的值，如果传递的是一个可调用对象，则为调用后的结果。在大部分情形下，传递一个可调用对象用于避免models.py 在导入时执行查询：

  ```
  from django.conf import settings
  from django.contrib.auth import get_user_model
  from django.db import models

      def get_sentinel_user():
          return get_user_model().objects.get_or_create(username='deleted')[0]

      class MyModel(models.Model):
          user = models.ForeignKey(settings.AUTH_USER_MODEL,
                         on_delete=models.SET(get_sentinel_user))
  ```


- DO_NOTHING

  不采取任何动作。如果你的数据库后端强制引用完整性，它将引发一个IntegrityError ，除非你手动添加一个ON DELETE 约束给数据库自动（可能要用到初始化的SQL）。

> **ForeignKey.swappable**

控制迁移框架的的重复行为如果该ForeignKey 指向一个可切换的模型。如果它是默认值True，那么如果ForeignKey 指向的模型与settings.AUTH_USER_MODEL 匹配（或其它可切换的模型），则保存在迁移中的关联关系将使用对setting 中引用而不是直接对模型的引用。

只有当你确定你的模型将永远指向切换后的模型 —— 例如如果它是专门为你的自定义用户模型设计的模型时，你才会想将它设置成`False`。

> **ForeignKey.allow_unsaved_instance_assignment**

添加这个标志是为向后兼容，因老版本Django 始终允许赋值未保存的模型实例。

Django 阻止未保存的模型实例被分配给一个`ForeignKey` 字段以防止以外的数据丢失（当保存一个模型实例时，未保存的外键将默默忽略）。

如果你需要允许赋值未保存的实例且不关心数据的丢失（例如你不会保存对象到数据库），你可以通过创建这个字段的子类并设置其allow_unsaved_instance_assignment 属性为True 来关闭这个检查。例如：

```
class UnsavedForeignKey(models.ForeignKey):
    # A ForeignKey which can point to an unsaved object
    allow_unsaved_instance_assignment = True

class Book(models.Model):
    author = UnsavedForeignKey(Author)
```

**ManyToManyField**

```
class ManyToManyField(othermodel[, **options])
```

一个多对多关联。要求一个关键字参数：与该模型关联的类，与[`ForeignKey`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.ForeignKey) 的工作方式完全一样，包括[*递归关系*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#recursive-relationships) 和[*惰性关系*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#lazy-relationships)。

关联的对象可以通过字段的[`RelatedManager`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/relations.html#django.db.models.fields.related.RelatedManager) 添加、删除和创建。

###### 在数据库中的表示

在幕后，Django 创建一个中间表来表示多对多关系。**默认情况下，这张中间表的名称使用多对多字段的名称和包含这张表的模型的名称生成。因为某些数据库支持的表的名字的长度有限制，这些标的名称将自动截短到64 个字符并加上一个唯一性的哈希值。**这意味着，你看的表的名称可能类似 author_books_9cdf4；这再正常不过了。你可以使用db_table 选项手工提供中间表的名称。

###### 参数

ManyToManyField 接收一个参数集来控制关联关系的功能，它们都是可选的。

与ForeignKey相同的参数：

> - ManyToManyField.related_name
>
> - ManyToManyField.related_query_name
>
> - ManyToManyField.limit_choices_to
>
>   limit_choices_to 对于使用through 参数自定义中间表的ManyToManyField 不生效。

> **ManyToManyField.symmetrical**

只用于与自身进行关联的ManyToManyField。例如下面的模型：

```
from django.db import models

class Person(models.Model):
    friends = models.ManyToManyField("self")
```

当Django 处理这个模型的时候，它定义该模型具有一个与自身具有多对多关联的ManyToManyField，因此它不会向Person 类添加person_set 属性。Django 将假定这个ManyToManyField 字段是对称的 —— **如果我是你的朋友，那么你也是我的朋友。**

如果你希望与self 进行多对多关联的关系不具有对称性，可以设置symmetrical为False。这会强制让Django 添加一个描述器给反向的关联关系，以使得ManyToManyField 的关联关系不是对称的。

> **ManyToManyField.through**

Django 会自动创建一个表来管理多对多关系。不过，如果你希望手动指定中介表，可以使用through 选项来指定Django 模型来表示你想要使用的中介表。

这个选项最常见的使用场景是当你想要关联[*额外的数据到多对多关联关系*](https://wizardforcel.gitbooks.io/topics/db/models.html#intermediary-manytomany)的时候。

如果你没有显式指定`through` 的模型，仍然会有一个隐式的`through` 模型类，你可以用它来直接访问对应的表示关联关系的数据库表。它由三个字段来链接模型。

如果源模型和目标不同，则生成以下字段：

- id：关系的主键。
- <containing_model>_id：声明ManyToManyField 字段的模型的id。
- <other_model>_id：ManyToManyField 字段指向的模型的id。

如果ManyToManyField 的源模型和目标模型相同，则生成以下字段：

- `id`：关系的主键。
- `from_<model>_id`：源模型实例的`id`。
- `to_<model>_id`：目标模型实例的`id`。

这个类可以让一个给定的模型像普通的模型那样查询与之相关联的记录。

> **ManyToManyField.through_fields**

只能在指定了自定义中间模型的时候使用。 Django 一般情况会自动决定使用中间模型的哪些字段来建立多对多关联。但是，考虑如下模型：

```
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'))

class Membership(models.Model):
    group = models.ForeignKey(Group)
    person = models.ForeignKey(Person)
    inviter = models.ForeignKey(Person, related_name="membership_invites")
    invite_reason = models.CharField(max_length=64)
```

Membership 有两个 外键指向Person （person 和inviter），这使得关联关系含混不清并让Django 不知道使用哪一个。在这种情况下，你必须使用through_fields 明确指定Django 应该使用哪些外键。

`through_fields` 接收一个二元组`('field1', 'field2')`，其中`field1` 为指向定义[`ManyToManyField`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.ManyToManyField) 字段的模型的外键名称（本例中为`group`），`field2` 为指向目标模型的外键的名称（本例中为`person`）。

当中间模型具有多个外键指向多对多关联关系模型中的任何一个（或两个），你*必须* 指定`through_fields`。这通用适用于[*递归的关联关系*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#recursive-relationships)，当用到中间模型而有多个外键指向该模型时，或当你想显式指定Django 应该用到的两个字段时。

递归的关联关系使用的中间模型始终定义为非对称的，也就是symmetrical=False—— 所以具有源和目标的概念。这种情况下，'field1' 将作为管理关系的源，而'field2' 作为目标。

> **ManyToManyField.db_table**

为存储多对多数据而创建的表的名称。如果没有提供，Django 将基于定义关联关系的模型和字段假设一个默认的名称。

> **ManyToManyField.db_constraint**

控制中间表中的外键是否创建约束。默认为True，而且这是几乎就是你想要的；设置为False 对数据完整性将非常糟糕。下面是你可能需要这样设置的一些场景：

- 你具有不合法的遗留数据。
- 你正在对数据库缩容。

不可以同时传递db_constraint 和 through。

> **ManyToManyField.swappable**

控制ManyToManyField 指向一个可切换的模型时迁移框架的行为。如果它是默认值True，那么如果ManyToManyField 指向的模型与settings.AUTH_USER_MODEL匹配（或其它可切换的模型），则保存在迁移中的关联关系将使用对setting 中引用而不是直接对模型的引用。

只有当你确定你的模型将永远指向切换后的模型 —— 例如如果它是专门为你的自定义用户模型设计的模型时，你才会想将它设置成`False`。

如果不确定，请将它保留为`True`。

> **ManyToManyField.allow_unsaved_instance_assignment**

与ForeignKey.allow_unsaved_instance_assignment 的工作方式类似。

[`ManyToManyField`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.ManyToManyField) 不支持[`validators`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.validators)。

[`null`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.null) 不生效，因为无法在数据库层次要求关联关系。

**OneToOneField**

```python
class OneToOneField(othermodel[, parent_link=False, **options])
```

一对一关联关系。概念上讲，这个字段很像是ForeignKey 设置了unique=True，不同的是它会直接返回关系另一边的单个对象。

它最主要的用途是作为扩展自另外一个模型的主键；例如，[*多表继承*](https://wizardforcel.gitbooks.io/topics/db/models.html#multi-table-inheritance)就是通过对子模型添加一个隐式的一对一关联关系到父模型实现的。

需要一个位置参数：与该模型关联的类。 它的工作方式与[`ForeignKey`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.ForeignKey) 完全一致，包括所有与[*递归关系*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#recursive-relationships)和[*惰性关系*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#lazy-relationships)相关的选项。

如果你没有指定OneToOneField 的related_name 参数，Django 将使用当前模型的小写的名称作为默认值。

例如下面的例子：

```
from django.conf import settings
from django.db import models

class MySpecialUser(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    supervisor = models.OneToOneField(settings.AUTH_USER_MODEL, related_name='supervisor_of')
```

你将使得User 模型具有以下属性：

```
>>> user = User.objects.get(pk=1)
>>> hasattr(user, 'myspecialuser')
True
>>> hasattr(user, 'supervisor_of')
True
```

当反向访问关联关系时，如关联的对象不存在对应的实例，则抛出DoesNotExist异常。例如，如果一个User 没有MySpecialUser 指定的supervisor：

```
>>> user.supervisor_of
Traceback (most recent call last):
    ...
DoesNotExist: User matching query does not exist.
```

OneToOneField 除接收ForeignKey 的所有额外的参数之外，还有另一个参数：

> **OneToOneField.parent_link**

当它为True 并在继承自另一个具体模型的模型中使用时，表示该字段应该用于反查的父类的链接，而不是在子类化时隐式创建的OneToOneField。

#### 3、Field API参考

```
class Field
```

Field 是一个抽象的类, 用来代表数据库中的表的一列. Django 使用这些fields 去创建表 (db_type()), 去建立Python中的类型和数据库中类型的映射关系 (get_prep_value()) 反之亦然 (from_db_value()), 并且实现Lookup API reference(get_prep_lookup()).

field 是不同Django版本API中最根本的部分，尤其是[`models`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/instances.html#django.db.models.Model) and [`querysets`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/querysets.html#django.db.models.query.QuerySet).

在模型中，一个字段被实例化为类的属性，并表现为一个特定的表的列，详情查看[*Models*](https://wizardforcel.gitbooks.io/topics/db/models.html). 它具有[`null`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.null)和[`唯一`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.unique)等属性，以及Django用于将字段值映射到数据库特定值的方法。

`字段`是[`RegisterLookupMixin`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/lookups.html#django.db.models.lookups.RegisterLookupMixin)的子类，因此可以在其上注册[`Transform`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/lookups.html#django.db.models.Transform)和[`Lookup`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/lookups.html#django.db.models.Lookup)`QuerySet` s（例如`field_name__exact =“foo”`）。默认情况下，所有[*内置查找*](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/querysets.html#field-lookups)都已注册。

Django的所有内建字段，如CharField都是Field的特定实现。如果您需要自定义字段，则可以将任何内置字段子类化，也可以从头开始写入字段。

> **description**

字段的详细说明，例如用于django.contrib.admindocs应用程序。

```
description = _("String (up to %(max_length)s)")
```

其中参数从字段的__ dict __插入



为了将一个Field映射到特定于数据库的类型，Django公开了两种方法：

> **get_internal_type()**

返回一个字符串，命名此字段以用于后端特定用途。默认情况下，它返回类名。

> **db_type(connection)**

返回字段的数据库列数据类型，同时考虑连接。

有三种主要情况，Django需要与数据库后端和字段交互：

- 当它查询数据库（Python值 转为 数据库后端值）
- 当它从数据库加载数据（数据库后端值 转为 Python值）
- 当它保存到数据库（Python值 转为 数据库后端值）



查询时，使用get_db_prep_value()和get_prep_value()：

> **get_prep_value(value)**

`value`是模型属性的当前值，方法应以已准备好用作查询中的参数的格式返回数据。

> **get_db_prep_value(value, connection, prepared=False)**

将值转换为后端特定值。如果prepared = True和get_prep_value() if为False，则默认返回值。



加载数据时，使用from_db_value()：

> **from_db_value(value, expression, connection, context)**

将数据库返回的值转换为Python对象。它与[`get_prep_value()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.get_prep_value)相反。

此方法不用于大多数内置字段，因为数据库后端已返回正确的Python类型，或后端本身执行转换。

> 注意
>
> 出于性能原因，from_db_value在不需要它的字段（所有Django字段）上不实现为无操作。因此，您不能在定义中调用super。



保存时，使用pre_save()和get_db_prep_save()

> **get_db_prep_save(value, connection)**

与[`get_db_prep_value()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.get_db_prep_value)相同，但在字段值必须*保存到数据库*时调用。默认返回[`get_db_prep_value()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.get_db_prep_value)。

> **pre_save(model_instance, add)**

在[`get_db_prep_save()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.get_db_prep_save)之前调用方法以在保存之前准备值（例如，对于[`DateField.auto_now`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.DateField.auto_now)）。

`model_instance`是此字段所属的实例，`add`是实例是否第一次保存到数据库。

它应该返回此字段的model_instance适当属性的值。属性名称位于self.attname（这是由Field设置）。



当在字段上使用查找时，该值可能需要“准备”。Django公开了两种方法：

> **get_prep_lookup(lookup_type, value)**

在用于查找之前，准备`values`到数据库。The `lookup_type` will be one of the valid Django filter lookups: `"exact"`, `"iexact"`, `"contains"`, `"icontains"`, `"gt"`, `"gte"`, `"lt"`, `"lte"`, `"in"`, `"startswith"`, `"istartswith"`, `"endswith"`, `"iendswith"`, `"range"`, `"year"`, `"month"`, `"day"`, `"isnull"`, `"search"`, `"regex"`, and `"iregex"`。

> get_db_prep_lookup(lookup_type, value, connection, prepared=False)

类似于get_db_prep_value()，但用于执行查找。

与get_db_prep_value()一样，将用于查询的特定连接作为connection传递。此外，prepared描述该值是否已经用get_prep_lookup()准备好。



字段经常从不同的类型接收它们的值，从序列化或从表单。

> **to_python(value)**

改变这个值为正确的python对象。它作为[`value_to_string()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/2_1_2_Field%20types.html#django.db.models.Field.value_to_string)的反向操作，也在[`clean()`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/content/instances.html#django.db.models.Model.clean)中调用。



除了保存到数据库，该字段还需要知道如何序列化其值：

> **value_to_string(obj)**

将`obj`转换为字符串。用于序列化字段的值。



当使用[`模型 表单`](https://wizardforcel.gitbooks.io/topics/forms/modelforms.html#django.forms.ModelForm)时，`Field`需要知道应由哪个表单字段表示：

> __formfield(form_class=None, choices_form_class=None, **kwargs)__

返回[`ModelForm`](https://wizardforcel.gitbooks.io/topics/forms/modelforms.html#django.forms.ModelForm)的此字段的默认[`django.forms.Field`](https://wizardforcel.gitbooks.io/django-chinese-docs-18/forms/fields.html#django.forms.Field)。



> **deconstruct()**

返回具有足够信息的4元组，以重新创建字段：

1. 模型上字段的名称。
2. 字段的导入路径。
3. 位置参数列表。
4. 关键字参数的字典。

#### 4、Field属性参考

> **Field.auto_created**

布尔标志，指示是否自动创建字段，例如模型继承使用的`OneToOneField`。

> **Field.concrete**

布尔标志，指示字段是否具有与其相关联的数据库列。

> **Field.hidden**

指示字段是否用于备份另一个非隐藏字段的功能的布尔标志（例如，构成GenericForeignKey的content_type和object_id字段）。 隐藏标志用于区分模型上所有字段的模型字段的公共子集。

> **Field.is_relation**

布尔标志，指示字段是否包含对一个或多个其他模型的功能的引用（例如ForeignKey，ManyToManyField，OneToOneField等） 。

> **Field.model**

返回定义字段的模型。如果在模型的超类上定义了字段，则`模型`将引用超类，而不是实例的类。

###### 具有关系的字段的属性

> **Field.many_to_many**

如果字段具有多对多关系，则布尔标志为True；否则为False。Django中包含的唯一字段是ManyToManyField。

> **Field.many_to_one**

如果字段具有多对一关系，例如`ForeignKey`，则布尔标志为`True`；否则为`False`。

> **Field.one_to_many**

如果字段具有一对多关系（例如`GenericRelation`或`ForeignKey`的反向），则`True`的布尔标志；否则为`False`。

> **Field.one_to_one**

如果字段具有一对一关系，例如`OneToOneField`，则布尔标志为`True`；否则为`False`。

> **Field.related_model**

指向字段涉及的模型。例如，ForeignKey(Author)中的Author。如果字段具有通用关系（例如GenericForeignKey或GenericRelation），则related_model将为None。

### C、元选项

以下是Meta类所有可用的元选项，你可在模型的Meta类中设置他们。

**abstract**

如果 abstract = True， 就表示模型是 抽象基类 (abstract base class)。

**app_label**

如模型定义在默认的 models.py 之外，必须告诉 Django 该模型属于哪个应用：

```
app_label = 'myapp'
```

**db_table**

该模型所用的数据表的名称：

```
db_table = 'music_album'
```

> > **数据表名称**
>
> 为了节省时间，Django 会根据模型类的名称和包含它的app名称自动指定数据表名称，一个模型的数据表名称，由这个模型的“应用标签”（在 manage.py startapp中使用的名称）之间加上下划线组成。举个例子， bookstore应用(使用 manage.py startapp bookstore 创建)，里面有个名为 Book的模型，那数据表的名称就是 bookstore_book 。
>
> 使用 Meta类中的 db_table 参数来覆写数据表的名称。
>
> 数据表名称可以是 SQL 保留字，也可以包含不允许出现在 Python 变量中的特殊字符，这是因为 Django 会自动给列名和表名添加引号。

**db_tablespace**

当前模型所使用的数据库表空间 的名字。默认值是项目设置中的DEFAULT_TABLESPACE，如果它存在的话。如果后端并不支持表空间，这个选项可以忽略。

**default_related_name**

这个名字会默认被用于一个关联对象到当前对象的关系。默认为 _set。

由于一个字段的反转名称应该是唯一的，当你给你的模型设计子类时，要格外小心。为了规避名称冲突，名称的一部分应该含有'%(app_label)s'和'%(model_name)s'，它们会被应用标签的名称和模型的名称替换，二者都是小写的。详见抽象模型的关联名称。

**get_latest_by**

模型中某个可排序的字段的名称，比如DateField、DateTimeField或者IntegerField。它指定了Manager的latest()和earliest()中使用的默认字段。

```
get_latest_by = "order_date"
```

**managed**

默认为True，意思是Django在migrate命令中创建合适的数据表，并且会在 flush 管理命令中移除它们。换句话说，Django会管理这些数据表的生命周期。

如果是False，Django 就不会为当前模型创建和删除数据表。如果当前模型表示一个已经存在的，通过其它方法建立的数据库视图或者数据表，这会相当有用。这是设置为managed=False时唯一的不同之处。. 模型处理的其它任何方面都和平常一样。

**order_with_respect_to**

按照给定的字段把这个对象标记为”可排序的“。这一属性通常用到关联对象上面，使它在父对象中有序。

比如，如果Answer和 Question相关联，一个问题有至少一个答案，并且答案的顺序非常重要，你可以这样做：

```
from django.db import models

class Question(models.Model):
    text = models.TextField()
    # ...

class Answer(models.Model):
    question = models.ForeignKey(Question)
    # ...

    class Meta:
        order_with_respect_to = 'question'
```

当order_with_respect_to 设置之后，模型会提供两个用于设置和获取关联对象顺序的方法：get_RELATED_order() 和set_RELATED_order()，其中RELATED是小写的模型名称。例如，假设一个 Question 对象有很多相关联的Answer对象，返回的列表中含有相关联Answer对象的主键：

```
>>> question = Question.objects.get(id=1)
>>> question.get_answer_order()
[1, 2, 3]
```

与Question对象相关联的Answer对象的顺序，可以通过传入一格包含Answer 主键的列表来设置：

```
>>> question.set_answer_order([3, 1, 2])
```

相关联的对象也有两个方法， get_next_in_order() 和get_previous_in_order()，用于按照合适的顺序访问它们。假设Answer对象按照 id来排序：

```
>>> answer = Answer.objects.get(id=2)
>>> answer.get_next_in_order()
<Answer: 3>
>>> answer.get_previous_in_order()
<Answer: 1>
```

> 修改 order_with_respect_to
>
> order_with_respect_to属性会添加一个额外的字段（数据表中的列）叫做_order，所以如果你在首次迁移之后添加或者修改了order_with_respect_to属性，要确保执行和应用了合适的迁移操作。

**ordering**

对象默认的顺序，获取一个对象的列表时使用：

```
ordering = ['-order_date']
```

它是一个字符串的列表或元组。每个字符串是一个字段名，前面带有可选的“-”前缀表示倒序。前面没有“-”的字段表示正序。使用"?"来表示随机排序。

先按照pub_date的倒序排序，再按照 author 的正序排序，这样写：

```
ordering = ['-pub_date', 'author']
```

> 警告
>
> 排序并不是没有任何代价的操作。你向ordering属性添加的每个字段都会产生你数据库的开销。你添加的每个外键也会隐式包含它的默认顺序。

**permissions**

设置创建对象时权限表中额外的权限。增加、删除和修改权限会自动为每个模型创建。这个例子指定了一种额外的权限，can_deliver_pizzas：

```
permissions = (("can_deliver_pizzas", "Can deliver pizzas"),)
```

它是一个包含二元组的元组或者列表，格式为 (permission_code, human_readable_permission_name)。

**default_permissions**

默认为('add', 'change', 'delete')。你可以自定义这个列表，比如，如果你的应用不需要默认权限中的任何一项，可以把它设置成空列表。在模型被migrate命令创建之前，这个属性必须被指定，以防一些遗漏的属性被创建。

**proxy**

如果proxy = True, 作为该模型子类的另一个模型会被视为代理模型。

**unique_together**

用来设置的不重复的字段组合：

```
unique_together = (("driver", "restaurant"),)
```

它是一个元组的元组，组合起来的时候必须是唯一的。它在Django后台中被使用，在数据库层上约束数据(比如，在 CREATE TABLE 语句中包含 UNIQUE语句)。

为了方便起见，处理单一字段的集合时，unique_together 可以是一维的元组：

```
unique_together = ("driver", "restaurant")
```

**index_together**

用来设置带有索引的字段组合：

```
index_together = [
    ["pub_date", "deadline"],
]
```

列表中的字段将会建立索引（例如，会在CREATE INDEX语句中被使用）。

**verbose_name**

对象的一个易于理解的名称，为单数：

```
verbose_name = "pizza"
```

如果此项没有设置，Django会把类名拆分开来作为自述名，比如CamelCase 会变成camel case，

**verbose_name_plural**

该对象复数形式的名称：

```
verbose_name_plural = "stories"
```

如果此项没有设置，Django 会使用 verbose_name + "s"。

### D、模型类

#### 属性 — objects

```
Model.objects
```

每个非抽象的`Model` 类必须给自己添加一个`Manager`实例。Django 确保在你的模型类中至少有一个默认的`Manager`。如果你没有添加自己的`Manager`，Django 将添加一个属性`objects`，它包含默认的`Manager` 实例。如果你添加自己的`Manager`实例的属性，默认值则不会出现。

```
from django.db import models

class Person(models.Model):
    # 用另一个名字替代manage
    people = models.Manager()
```

## 二、查询集

###### 博客应用原型：

```python
from django.db import models

class Blog(models.Model):
    '''博客表'''
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Author(models.Model):
    '''作者表'''
    name = models.CharField(max_length=50)
    email = models.EmailField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Entry(models.Model):
    '''文章表'''
    blog = models.ForeignKey(Blog)
    authors = models.ManyToManyField(Author)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):              # __unicode__ on Python 2
        return self.headline
```

### A、执行查询

一旦你建立好*数据模型*之后，django会自动生成一套数据库抽象的API，可以让你执行增删改查的操作。

#### 1、创建对象

为了把数据库表中的数据表示成python对象，django使用一种直观的方式：一个模型类代表数据库的一个表，一个模型的实例代表数据库表中的一条特定的记录。

使用关键词参数实例化一个对象来创建它，然后调用**save()**把它保存到数据库中。

```
>>> from blog.models import Blog
>>> b = Blog(name='Beatles', tagline='All the latest Beatles news.')
>>> b.save()
```

此代码在背后执行sql的**INSERT**操作，在显式调**save()**前,django不访问数据库。

#### 2、保存对象的改动

调用**save()**方法，来保存已经存在于数据库中的对象的改动。

更新改动记录：

```
>>> b5.name = 'New name'
>>> b5.save()
```

此代码在背后执行了sql的**UPDATE**操作,在显式调**save()**前,django不访问数据库。

##### 保存ForeignKey和ManyToManyField字段

1. 更新**ForeignKey**字段的方式是把一个类型正确的对象赋值到字段中：

```
>>> from blog.models import Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()
```

2. 更新**ManyToManyField**的方式是使用**add()**方法来增加关系的记录：

```
>>> from blog.models import Author
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)
```

3. 在一条语句中，向**ManyToManyField**添加多条记录，可在调**add()**方法时传入多个参数：

```
>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)
```

Django将会在你添加错误类型的对象时抛出异常。

#### 3、获取对象

通过模型中的Manager构造一个QuertSet，来从你的数据库中获取对象。

你可以从模型的**Manager**那里取得**QuerySet**。每个模型都至少有一个**Manager**，它通常命名为**objects**。通过模型类直接访问它，像这样：

```
>>> Blog.objects
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name='Foo', tagline='Bar')
>>> b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
```

> **注意**
>
> 管理器通常只可以通过模型类来访问，不可以通过模型实例来访问。这是为了强制区分表级别和记录级别的操作。

对于一个模型来说，**Manager**是**QuerySet**的主要来源。例如，**Blog.objects.all()** 会返回持有数据库中所有**Blog**对象的一个**QuerySet**。

##### a、获取所有对象

使用**Manager**的**all()**方法：

```
>>> all_entries = Entry.objects.all()
```

##### b、使用过滤器获取特定对象

两个最普遍的途径是：

> filter(**kwargs) 返回一个包含对象的集合，它们满足参数中所给的条件。
>
> exclude(**kwargs) 返回一个包含对象的集合，它们不满足参数中所给的条件。

要获取年份为2006的所有文章的结果集，可以这样使用filter()方法：

```
Entry.objects.filter(pub_date__year=2006)
```

在默认的管理器类中，它相当于：

```
Entry.objects.all().filter(pub_date__year=2006)
```

###### 链式过滤

QuerySet的精炼结果还是QuerySet，故你可把精炼用的语句组合，像这样：

```
Entry.objects.filter(headline__startswith='What').exclude(pub_date__gte=datetime.date.today()).filter(pub_date__gte=datetime(2005, 1, 30))
```

最开始的QuerySet包含数据库中的所有对象，之后增加一个过滤器去掉一部分，在之后又是另外一个过滤器。最后的结果的一个QuerySet，包含所有标题以”word“开头的记录，并且日期是2005年一月，日为当天的值。

###### 过滤后的结果集是独立的

每次你筛选一个结果集，得到的都是全新的另一个结果集，它和之前的结果集之间没有任何绑定关系。每次筛选都会创建一个独立的结果集，可以被存储及反复使用。

```
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today()) 
```

- 第一个 QuerySet 包含大标题以"What"开头的所有记录。
- 第二个是第一个的子集，用一个附加条件排除出版日期 pub_date 是今天的记录。 
- 第三个也是第一个的子集，它只保留出版日期 pub_date 是今天的记录。
- 最初的 QuerySet (q1) 没有受到筛选的影响。

#### 4、查询集是延迟的

QuerySets 是惰性的 -- 创建 QuerySet 的动作不涉及任何数据库操作。你可以一直添加过滤器，在这个过程中，Django 不会执行任何数据库查询，除非 QuerySet 被执行。

```
>>> q = Entry.objects.filter(headline__startswith="What")
>>> q = q.filter(pub_date__lte=datetime.now())
>>> q = q.exclude(body_text__icontains="food")
>>> print q
```

虽然上面的代码看上去象是三个数据库操作，但实际上只在最后一行 (print q) 执行了一次数据库操作。

一般情况下， QuerySet 不能从数据库中主动地获得数据，得被动地由你来请求。对 QuerySet 求值就意味着 Django 会访问数据库。

#### 5、限制查询集范围

可以用 python 的数组切片语法来限制你的 QuerySet 以得到一部分结果。它等价于SQL中的 LIMIT 和 OFFSET 。

这个例子返回前五个对象 (LIMIT 5):

```
>>> Entry.objects.all()[:5]
```

这个例子返回第六到第十之间的对象 (OFFSET 5 LIMIT 5):

```
>>> Entry.objects.all()[5:10]
```

**Django 不支持对查询集做负数索引 (例如 Entry.objects.all()[-1]) 。**

一般来说，对 QuerySet 切片会返回新的 QuerySet -- 这个过程中不运行查询。但在切片时使用了 "step" 参数，查询集就会被求值，在数据库中运行查询。如，使用下面这个这个查询集返回前十个对象中的偶数次对象，就会运行数据库查询:

```
>>> Entry.objects.all()[:10:2]
```

要检索单独对象,而非列表 (比如 SELECT foo FROM bar LIMIT 1)，可用索引来代替切片。

```
>>> Entry.objects.order_by('headline')[0]
```

大约等价于：

```
>>> Entry.objects.order_by('headline')[0:1].get()
```

要注意的是：如果找不到符合条件的对象，第一种方法会抛出 IndexError ，而第二种方法会抛出 DoesNotExist。

#### 6、字段筛选条件

字段筛选条件就是 SQL 语句中的 WHERE 从句。就是 D**jango 中的 QuerySet 的 filter(), exclude() 和 get() 方法中的关键字参数。**

筛选条件的形式是 field__lookuptype=value 。 (**注意：这里是双下划线**)。如：

```
>>> Entry.objects.filter(pub_date__lte='2006-01-01')
```

可翻译为如下的 SQL 语句:

```
SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';
```

> **这是怎么办到的？**
>
> Python 允许函式接受任意多 name-value 形式的参数，并在运行时才确定name和value的值。如果你传递了一个无效的关键字参数，会抛出 TypeError 导常。

数据库 API 支持24种查询类型；这里我们列出一些常用的查询类型：

> **exact**

大小写敏感的精确匹配。例如：

```
>>> Entry.objects.get(headline__exact="Man bites dog")
```

会生成如下的 SQL 语句：

```
SELECT ... WHERE headline = 'Man bites dog';
```

如果你没有提供查询类型 -- 也就是说关键字参数中没有双下划线，那么查询类型就会被指定为 exact。

> **iexact**

忽略大小写的精确匹配。所以下面的这个查询:

```
>>> Blog.objects.get(name__iexact="beatles blog")
```

> **contains**

大小写敏感的模糊匹配。 例如：

```
Entry.objects.get(headline__contains='Lennon')
```

大体可以翻译为如下的 SQL：

```
SELECT ... WHERE headline LIKE '%Lennon%';
```

> **startswith, endswith**

分别匹配开头和结尾，同样也有忽略大小写的版本 istartswith 和 iendswith。

#### 7、跨关系查询

Django 提供一种直观高效的方式在查询中表示关联关系，自动确认 SQL JOIN 联系。**要做跨关系查询，就使用两个下划线来链接模型(model)间关联字段的名称，直到最终链接到你想要的 model 为止。**

这个例子检索所有关联 Blog 的 name 值为 'Beatles Blog' 的所有 Entry 对象：

```
>>> Entry.objects.filter(blog__name__exact='Beatles Blog')
```

**跨关系的筛选条件可以一直延展。**

**关系也是可逆的。可以在目标 model 上使用源 model 名称的小写形式得到反向关联。**

这个例子检索至少关联一个 Entry 且大标题 headline 包含 'Lennon' 的所有 Blog 对象：

```
>>> Blog.objects.filter(entry__headline__contains='Lennon')
```

如果在某个关联 model 中找不到符合过滤条件的对象，Django 将视它为一个空的 (所有的值都是 NULL), 但是可用的对象。这意味着不会有异常抛出：

```
Blog.objects.filter(entry__author__name='Lennon')
```

若没有author 与 entry 相关联，Django 会认为它没有 name 属性，而不会因不存在 author 抛出异常。通常来说，这正是你所希望的机制。唯一例外是使用 isnull 的情况：

```
Blog.objects.filter(entry__author__name__isnull=True)
```

###### 跨一对多／多对多关系

**对于包含在同一个 filter() 中的筛选条件，查询集要同时满足所有筛选条件。而对于连续的 filter() ，查询集的范围是依次限定的。**但对于跨一对多／多对多关系查询来说，在第二种情况下，筛选条件针对的是主 model 所有的关联对象，而不是被前面的 filter() 过滤后的关联对象。

例如，要检索这样的 blog：它要关联一个大标题中含有 "Lennon" 并且在2008年出版的 entry (这个 entry 同时满足这两个条件)，可这样写：

```
Blog.objects.filter(entry__headline__contains='Lennon',
        entry__pub_date__year=2008)
```

要检索另外一种 blog：它关联一个大标题含有"Lennon"的 entry ，又关联一个在2008年出版的 entry （一个 entry 的大标题含有 Lennon，同一个或另一个 entry 是在2008年出版的）。可以这样写：

```
Blog.objects.filter(entry__headline__contains='Lennon').filter(
        entry__pub_date__year=2008)
```

**在第二个例子中，第一个过滤器(filter)先检索与符合条件的 entry 的相关联的所有 blogs。第二个过滤器在此基础上从这些 blogs 中检索与第二种 entry 也相关联的 blog。第二个过滤器选择的 entry 可能与第一个过滤器所选择的完全相同，也可能不同。 因为过滤项过滤的是 Blog，而不是 Entry。**

###### 在过滤器中引用 model 中的字段

如果我们要对两个字段值做比较，那该怎么做呢？

Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。

例如：要查询评论数大于转发数的博文，可构造一个 F() 对象在查询中引用评论数量：

```
>>> from django.db.models import F
>>> Entry.objects.filter(n_pingbacks__lt=F('n_comments'))
```

Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。

例如，要找到广播数等于评论数两倍的博文，可以这样修改查询语句：

```
>>> Entry.objects.filter(n_pingbacks__lt=F('n_comments') * 2)
```

要查找阅读数量小于评论数与广播数之和的博文，查询如下:

```
>>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))
```

你也可以在 F() 对象中使用两个下划线做跨关系查询。F() 对象使用两个下划线引入必要的关联对象。

如，查询博客名称与作者名称相同的博文(entry)，查询就可以这样写：

```
>>> Entry.objects.filter(author__name=F('blog__name'))
```

#### 8、主键查询的简捷方式

Django 用 pk 代表主键"primary key"。

以 Blog 为例, 主键是 id 字段，所以下面三个语句都是等价的：

```
>>> Blog.objects.get(id__exact=14)
>>> Blog.objects.get(id=14)
>>> Blog.objects.get(pk=14)
```

pk 对 __exact 查询同样有效，任何查询项都可以用 pk 来构造基于主键的查询：

```
# 获取id为1、4、7的记录
>>> Blog.objects.filter(pk__in=[1,4,7])

# 获取id>14的记录
>>> Blog.objects.filter(pk__gt=14)
```

pk 查询也可以跨关系，下面三个语句是等价的：

```
>>> Entry.objects.filter(blog__id__exact=3) 
>>> Entry.objects.filter(blog__id=3) 
>>> Entry.objects.filter(blog__pk=3) 
```

#### 9、在LIKE语句中转义 % 和 _

字段筛选条件相当于 LIKE SQL 语句 (exact, contains等) ，它会自动转义两个特殊符号 -- 百分号%和下划线。(在 LIKE 语句中，百分号%表多字符匹配，而下划线表单字符匹配。)

这意味着可直接使用这两个字符，而不用考虑 SQL 语义。如，查询大标题中含有一个百分号%的 entry：

```
>>> Entry.objects.filter(headline__contains='%')
```

Django 会处理转义；最终的 SQL 看起来会是这样：

```
SELECT ... WHERE headline LIKE '%\%%';
```

下划线_和百分号%的处理方式相同，Django 都会自动转义。

#### 10、缓存和查询

###### 牢记：

> 每个 QuerySet 都包含一个缓存，以减少对数据库的访问。要编写高效代码，就要理解缓存是如何工作的。**一个 QuerySet 时刚刚创建的时候，缓存是空的。 QuerySet 第一次运行时，会执行数据库查询，接下来 Django 就在 QuerySet 的缓存中保存查询的结果，并根据请求返回这些结果(比如，后面再次调用这个 QuerySet 的时候)。再次运行 QuerySet 时就会重用这些缓存结果。**

```
>>> print [e.headline for e in Entry.objects.all()]
>>> print [e.pub_date for e in Entry.objects.all()]
```

这意味着相同的数据库查询将执行两次，事实上读取了两次数据库。而且，这两次读出来的列表可能并不完全相同，因为存在这种可能：在两次读取之间，某个 Entry 被添加到数据库中，或是被删除了。

要避免这个问题，只要简单地保存 QuerySet 然后重用即可：

```
>>> queryset = Poll.objects.all()
>>> print [p.headline for p in queryset] # 求值查询集。
>>> print [p.pub_date for p in queryset] # 重新使用求值中的缓存。
```

###### 用 Q 对象实现复杂查找

在 filter() 等函数中关键字参数彼此间都是 "AND" 关系。如果你要执行更复杂的查询(比如，实现筛选条件的 OR 关系)，可使用 Q 对象。

**Q 对象(django.db.models.Q)是用来封装一组查询关键字的对象。**

如，下面这个 Q 对象封装了一个单独的 LIKE 查询：

```python
Q(question__startswith='What')
```

**Q 对象可以用 & 和 | 运算符进行连接。当某个操作连接两个 Q 对象时，就会产生一个新的等价的 Q 对象。**

例如，下面这段语句就产生了一个 Q ：

```
Q(question__startswith='Who') | Q(question__startswith='What')
```

上面的例子等价于下面的 SQL WHERE 从句：

```
WHERE question LIKE 'Who%' OR question LIKE 'What%'
```

**你可以用 & 和 | 连接任意多的 Q 对象，而且可以用括号分组。Q 对象也可以用 ~ 操作取反，而且普通查询和取反查询(NOT)可以连接在一起使用**：

```
Q(question__startswith='Who') | ~Q(pub_date__year=2005)
```

每种查询函式(比如 filter(), exclude(), get()) 除了能接收关键字参数以外，也能以位置参数的形式接受一个或多个 Q 对象。**如果你给查询函式传递了多个 Q 对象，那么它们彼此间都是 "AND" 关系。**例如：

```
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

大体可以翻译为下面的 SQL：

```
SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
```

查找函数可混用 Q 对象和关键字参数。查询函数的所有参数(Q 关系和关键字参数) 都是 "AND" 关系。但是，**如果参数中有 Q 对象，它必须排在所有的关键字参数之前。**例如：

```
Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith='Who')
```

下面这个查询虽然看上去和前者等价，但却是无效的：

```
# INVALID QUERY
Poll.objects.get(
    question__startswith='Who',
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)))
```

#### 11、对象的比较、删除、关联操作

##### a、对象比较

**比较两个对象，和 Python 一样，用双等号运算符：==。实际上比较的是两个 model 的主键值。**

以 Entry 为例，下面两个语句是等价的：

```
>>> some_entry == other_entry
>>> some_entry.id == other_entry.id
```

如果model 的主键名称不是 id也没关系。Django 会自动比较主键值，而不管他们的名称是什么。

```
>>> some_obj == other_obj
>>> some_obj.name == other_obj.name
```

##### b、对象删除

删除方法就是 delete()。它运行时立即删除对象而不返回任何值。例如：

```
e.delete()
```

你可以一次性删除多个对象。每个 QuerySet 都有一个 delete() 方法，它一次性删除 QuerySet 中所有的对象。

例如，下面的代码将删除 pub_date 是2005年的 Entry 对象：

```
Entry.objects.filter(pub_date__year=2005).delete()
```

###### 牢记：

> 无论在什么情况下，QuerySet 中的 delete() 方法都只使用一条 SQL 语句一次性删除所有对象，而并不是分别删除每个对象。如果你想使用在 model 中自定义的 delete() 方法，就要自行调用每个对象的delete 方法。(例如，遍历 QuerySet，在每个对象上调用 delete()方法)，而不是使用 QuerySet 中的 delete()方法。

在 Django 删除对象时，会模仿 SQL 约束 ON DELETE CASCADE 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。例如：

```
b = Blog.objects.get(pk=1)
# 这将删除blog及其所有Entry对象。
b.delete()
```

注意：

> delete() 方法是 QuerySet 上的方法，但并不适用于 Manager 本身。这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除。

如果你确认要删除所有的对象，那么你必须显式地调用：

```
Entry.objects.all().delete()
```

###### 一次更新多个对象

一次更新某个字段的值，可用 update() 方法完成。如：

```
# 更新所有出版日期是2007的headline
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')
```

这种方法仅适用于非关系字段和 ForeignKey 外键字段。更新非关系字段时，传入的值应该是一个常量。更新 ForeignKey 字段时，传入的值应该是你想关联的那个类的某个实例。例如：

```
>>> b = Blog.objects.get(pk=1)
# Change every Entry so that it belongs to this Blog.
>>> Entry.objects.all().update(blog=b)
```

**update() 方法也是即时生效，不返回任何值的。 在 QuerySet 进行更新时，唯一的限制就是一次只能更新一个数据表，就是当前 model 的主表。所以不要尝试更新关联表和与此类似的操作，因为这是不可能运行的。**

注意：

> update() 方法是直接翻译成一条 SQL 语句的。因此它是直接地一次完成所有更新。它不会调用你的 model 中的 save() 方法，也不会发出 pre_save 和 post_save 信号(这些信号在调用 save() 方法时产生)。如果你想保存 QuerySet 中的每个对象，并且调用每个对象各自的 save() 方法，那么你不必另外多写一个函式。只要遍历这些对象，依次调用 save() 方法即可。

```
for item in my_queryset:
    item.save()
```

在调用 update 时可以使用 F() 对象来把某个字段的值更新为另一个字段的值。这对于自增记数器是很有用的。如，给所有的entry 的转发数加一：

```
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)
```

但是，与 F() 对象在查询时所不同的是，在filter 和 exclude子句中，你不能在 F() 对象中引入关联关系(NO-Join)，你只能引用当前 model 中要更新的字段。如果你在 F() 对象引入了Join 关系object，就会抛出 FieldError 异常：

```
# THIS WILL RAISE A FieldError
>>> Entry.objects.update(headline=F('blog__name'))
```

##### c、对象关联

当在 model 定义关系时 (如， ForeignKey, OneToOneField, 或 ManyToManyField)，model 的实例自带一套很方便的API以获取关联的对象。

以最上面的 models 为例，一个 Entry 对象 e 能通过 blog 属性获得相关联的 Blog 对象： e.blog。

**(在场景背后，这个功能是由 Python 的 descriptors 实现的。如果你对此感兴趣，可以了解一下。)**

Django 也提供反向获取关联对象的 API，就是由从被关联的对象得到其定义关系的主对象。例如，一个 Blog 类的实例 b 对象通过 entry_set 属性得到所有相关联的 Entry 对象列表: b.entry_set.all()。

#### 12、关系

##### a、一对多关系

###### 正向查询

如果一个 model 有一个 ForeignKey字段，我们只要通过使用关联 model 的名称就可以得到相关联的外键对象。

```
>>> e = Entry.objects.get(id=2)
>>> e.blog # 返回相关联的Blog对象。
```

你可以设置和获得外键属性。正如你所期望的，改变外键的行为并不引发数据库操作，直到你调用 save()方法时，才会保存到数据库。例如：

```
>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()
```

如果外键字段 ForeignKey 有一个 null=True 的设置(它允许外键接受空值 NULL)，你可以赋给它空值 None 。例如：

```
>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save() 
```

在一对多关系中，第一次正向获取关联对象时，关联对象会被缓存。其后根据外键访问时这个实例，就会从缓存中获得它。例如：

```
>>> e = Entry.objects.get(id=2)
>>> print e.blog  # 点击数据库检索关联的blog。
>>> print e.blog  # 不查询数据库; 使用缓存版本。
```

**QuerySet 的 select_related() 方法提前将所有的一对多关系放入缓存中。**如：

```
>>> e = Entry.objects.select_related().get(id=2)
>>> print e.blog  # Doesn't hit the database; uses cached version.
>>> print e.blog  # Doesn't hit the database; uses cached version.
```

###### 逆向查询

> 如果 model 有一个 ForeignKey外键字段，那么外联 model 的实例可以通过访问 Manager 来得到所有相关联的源 model 的实例。默认情况下，这个 Manager 被命名为 FOO_set, 这里面的 FOO 就是源 model 的小写名称。这个 Manager 返回 QuerySets，它是可过滤和可操作的。

```
>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all() # 返回与Blog相关的所有Entry对象。

# b.entry_set是一个返回QuerySets的管理器。
>>> b.entry_set.filter(headline__contains='Lennon')
>>> b.entry_set.count()
```

你可以通过在 ForeignKey() 的定义中设置 related_name 的值来覆写 FOO_set 的名称。例如，如果 Entry model 中做一下更改： blog = ForeignKey(Blog, related_name='entries')，那么接下来就会如我们看到这般：

```
>>> b = Blog.objects.get(id=1)
>>> b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
>>> b.entries.filter(headline__contains='Lennon')
>>> b.entries.count()
```

你不能在一个类当中访问 ForeignKey Manager ；而必须通过类的实例来访问：

```
>>> Blog.entry_set
Traceback:
    ...
AttributeError: "Manager must be accessed via instance".
```

##### b、多对多关系

在多对多关系的任何一方都可以使用 API 访问相关联的另一方。多对多的 API 用起来和上面提到的 "逆向" 一对多关系关系非常相象。

唯一的差虽就在于属性的命名： ManyToManyField 所在的 model (为了方便，我称之为源model A) 使用字段本身的名称来访问关联对象；而被关联的另一方则使用 A 的小写名称加上 '_set' 后缀(这与逆向的一对多关系非常相象)。

```
e = Entry.objects.get(id=3)
e.authors.all()
e.authors.count()
e.authors.filter(name__contains='John')

a = Author.objects.get(id=5)
a.entry_set.all() 
```

##### c、一对一关系

如果你在 model 中定义了一个 OneToOneField 关系，那你就可以用这个字段的名称做为属性来访问其所关联的对象。

```
class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry)
    details = models.TextField()

ed = EntryDetail.objects.get(id=2)
ed.entry
```

与 "reverse" 查询不同的是，一对一关系的关联对象也可以访问 Manager 对象，但是这个 Manager 表现一个单独的对象，而不是一个列表：

```
e = Entry.objects.get(id=2)
e.entrydetail 
```

如果一个空对象被赋予关联关系，Django 就会抛出一个 DoesNotExist 异常。

和你定义正向关联所用的方式一样，类的实例也可以赋予逆向关联方系：

```
e.entrydetail = ed
```

#### 13、关系中的反向连接是如何做到的？

其他对象关系的映射(ORM)需要你在关联双方都定义关系。而 Django 的开发者则认为这违背了 DRY 原则 (Don't Repeat Yourself)，所以 Django 只需要你在一方定义关系即可。

仅由一个 model 类并不能知道其他 model 类是如何与它关联的，除非是其他 model 也被载入，那么这是如何办到的？

**答案就在于 INSTALLED_APPS 设置中。任何一个 model 在第一次调用时，Django 就会遍历所有的 INSTALLED_APPS 的所有 models，并且在内存中创建中必要的反向连接。本质上来说，INSTALLED_APPS 的作用之一就是确认 Django 完整的 model 范围。**

#### 14、在关联对象上的查询

**包含关联对象的查询与包含普通字段值的查询都遵循相同的规则。为某个查询指定某个值的时候，你可以使用一个类实例，也可以使用对象的主键值。**

例如，如果你有一个 Blog 对象 b ，它的 id=5, 下面三个查询是等价的：

```
Entry.objects.filter(blog=b) 
Entry.objects.filter(blog=b.id) 
Entry.objects.filter(blog=5) 
```

#### 15、直接使用SQL

如果你发现某个 SQL 查询用 Django 的数据库映射来处理会非常复杂的话，你可以使用直接写 SQL 来完成。

建议方式是在model 自定义方法或自定义 model 的 manager 方法来运行查询。

最后，要注意的是，Django的数据操作层仅是访问数据库的一个接口。你可以用其他的工具，编程语言，数据库框架来访问数据库。对你的数据库而言，没什么是非用 Django 不可的。

### B、查询集API参考

#### 1、何时对查询集求值

#### 2、Pickle(序列化)查询集

#### 3、查询集API

###### 返回新的查询集的方法

###### 不会返回查询集的方法

#### 4、字段筛选条件查找

###### 正则表达式

#### 5、聚合函数

###### 6、查询相关的类

### C、查找表达式

## 三、模型的实例

### A、实例方法

### B、访问关联对象

## 四、迁移

### A、迁移简介

### B、操作参考

### C、模式编辑器

### D、编写迁移

## 五、高级

### A、管理器

### B、原始的SQL查询

### C、事务

### D、聚合

### E、自定义字段

### F、多数据库

### G、自定义查找

### H、查询表达式

### I、条件表达式

### J、数据库函数

## 六、其他

### A、支持的数据库

### B、遗留的数据库

### C、提供初始数据

### D、优化数据库访问

PostgreSQL特色功能